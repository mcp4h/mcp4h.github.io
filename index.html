<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		<title>MCP Proposals</title>
		<link rel="preconnect" href="https://fonts.googleapis.com"/>
		<link
			rel="preconnect"
			href="https://fonts.gstatic.com"
			crossorigin/>
		<link
			href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600&family=Newsreader:opsz,wght@6..72,400;6..72,600&display=swap"
			rel="stylesheet"/>
		<link rel="stylesheet" href="styles.css"/>
	</head>
	<body>
		<header class="site-header">
			<div class="brand">
				<div class="brand-mark">mcp4h</div>
				<div class="brand-sub">MCP Proposals</div>
			</div>
			<nav class="site-nav">
				<a href="#ui">UI</a>
				<a href="#configuration">Configuration</a>
				<a href="#permissions">Permissions</a>
				<a href="https://github.com/mcp4h">Github</a>
			</nav>
		</header>
		<main class="content">
			<section class="hero">
				<div class="hero-copy">
					<p class="eyebrow">MCP Proposals.</p>
					<h1>Informing the user</h1>
					<p class="lede">
						MCP servers can encapsulate data that the user might not have easy access to.
						This means informing the user of what will be done, what has been done and the overall state of the data
						can be a challenge.
					</p>
					<p class="lede">
						So I've suggested a few extensions which are inspired by MCP Apps, stay MCP-compatible, opt-in, and do not change normal
            operations or inflate LLM token use.
					</p>
					<div class="hero-actions">
						<a class="btn" href="#ui">Start with UI</a>
						<a class="btn ghost" href="https://github.com/mcp4h">Check out the code</a>
					</div>
				</div>
				<div class="hero-card">
					<div class="card-title">At a glance</div>
					<ul class="card-list">
						<li>Human visualization of tool calls</li>
						<li>Human access to encapsulated data</li>
						<li>Standardized dry-run</li>
						<li>Runtime policies</li>
						<li>Scalable permissions</li>
					</ul>
				</div>
			</section>
			<section id="ui" class="section reveal longform">
				<div class="section-title">
					<h2>UI Proposal</h2>
					<p>There are two challenges: informing a user what a tool call did or will do. And informing the user of the overall state of the system.</p>
					<p>It's important to note that the user typically needs <b>different information</b> for this than the LLM.</p>
				</div>
				<div class="longform-content">
					<div class="longform-block">
						<h2>P(review)</h2>
						<p>
							The first challenge in MCP is informing the user of the impact a particular tool action has.
							If the user just looks at tool input or output, it might not tell the whole story.
						</p>
						<p>
							The LLM has a context built up over the conversation which may consist of different tool calls and interactions.
							Based on that context the LLM decides to perform a tool call to "replace this line with this other line". 
							For the user however, looking just at the input might not be enough. He may want to see the broader context of that line to understands what the replacement means.
						</p>
						<p>
							At the same time we don't want to add unnecessary tools to the MCP server that the LLM might get confused by. Instead we want to generate side effects that are aimed solely at the user and invisible to the LLM.
						</p>
						<p>
							In the file server I added to this project (the <code>mcp-fs</code> project), the <code>edit_file</code> tool call
							will always generate a visual diff (both unified and side-by-side) for human consumption and a structured diff for automated processing.
							If the tool call is simply allowed to pass, it can be stored for later viewing, however the server also supports a <code>_meta.preview</code> boolean toggle.
							This makes use of the MCP v2 addition of _meta keys to standardize a "dry run".
				 	 		The tool will generate the exact same output but not actually apply the change.
			  				The artifacts it generates can then be used to inform the user of what
							<i>would</i> happen were he to allow it. 
							Once allowed, the tool call can be rerun without the preview parameter.
						</p>
						<p>
							The screenshots are taken in the <code>mcp-test</code> tool which is also available and makes it easy to test the proposed extensions.
						</p>
					</div>
					<div class="ui-gallery">
						<figure class="ui-shot">
							<button
								type="button"
								class="ui-shot-button"
								data-lightbox-src="assets/images/mcp-invoke-preview.png"
								data-lightbox-alt="Preview of an MCP invoke with a dry-run summary."
								data-lightbox-caption="MCP invoke preview mode.">
								<img
									src="assets/images/mcp-invoke-preview.png"
									alt="Preview of an MCP invoke with a dry-run summary."/>
							</button>
							<figcaption>MCP invoke preview mode.</figcaption>
						</figure>
						<figure class="ui-shot">
							<button
								type="button"
								class="ui-shot-button"
								data-lightbox-src="assets/images/mcp-invoke-preview-ui1.png"
								data-lightbox-alt="Unified diff preview of an MCP invoke."
								data-lightbox-caption="Unified diff.">
								<img
									src="assets/images/mcp-invoke-preview-ui1.png"
									alt="Unified diff preview of an MCP invoke."/>
							</button>
							<figcaption>Unified diff.</figcaption>
						</figure>
						<figure class="ui-shot">
							<button
								type="button"
								class="ui-shot-button"
								data-lightbox-src="assets/images/mcp-invoke-preview-ui2.png"
								data-lightbox-alt="Full screen unified diff."
								data-lightbox-caption="Fullscreen unified diff.">
								<img
									src="assets/images/mcp-invoke-preview-ui2.png"
									alt="Full screen unified diff."/>
							</button>
							<figcaption>Fullscreen unified diff.</figcaption>
						</figure>
						<figure class="ui-shot">
							<button
								type="button"
								class="ui-shot-button"
								data-lightbox-src="assets/images/mcp-invoke-preview-ui3.png"
								data-lightbox-alt="Side by side diff view of the change."
								data-lightbox-caption="Side-by-side diff.">
								<img
									src="assets/images/mcp-invoke-preview-ui3.png"
									alt="Side by side diff view of the change."/>
							</button>
							<figcaption>Side-by-side diff.</figcaption>
						</figure>
						<figure class="ui-shot">
							<button
								type="button"
								class="ui-shot-button"
								data-lightbox-src="assets/images/mcp-invoke-preview-ui4.png"
								data-lightbox-alt="Dedicated diff output"
								data-lightbox-caption="Dedicated diff output">
								<img
									src="assets/images/mcp-invoke-preview-ui4.png"
									alt="Dedicated diff output"/>
							</button>
							<figcaption>Dedicated diff output</figcaption>
						</figure>
						<figure class="ui-shot">
							<button
								type="button"
								class="ui-shot-button"
								data-lightbox-src="assets/images/mcp-resources.png"
								data-lightbox-alt="Combination of static and dynamic resources."
								data-lightbox-caption="Combination of static and dynamic resources.">
								<img
									src="assets/images/mcp-resources.png"
									alt="Combination of static and dynamic resources."/>
							</button>
							<figcaption>Combination of static and dynamic resources.</figcaption>
						</figure>
					</div>
					<div class="longform-block">
						<h3>How the UI layer is delivered</h3>
						<p>
							Inspired by MCP apps, there is an MCP bridge (available in <code>mcp-ui</code>): a native web
              				component that renders HTML inside a sandboxed iframe. It exposes
              				a standard set of CSS variables that can be configured on the
							<code>mcp-view</code>, allowing the MCP UI to blend into the host
							application.
						</p>
						<p>
							For the file server, each <code>edit-file</code>
							tool call generates a temporary dynamic resource. 
							If you <i>can</i> inform the user based solely on input/output or existing tools, static resources are also possible.
							The link is currently added to the <code>content</code> array.
						</p>
					</div>
					<div class="longform-block">
						<h2>Context beyond a single tool call</h2>
						<p>
							MCP servers are frequently black boxes. They manage datasets the
							user might not be able to easily access, such as a remote or containerized instance. 
						</p>
						<p>
						  Sometimes the user needs more information regarding the state of the data.
						  This can help him decide which path to take or understand a larger set of changes.
						</p>
						<p>
							In the example file server I added this takes the form of a "file browser".
							It uses the same <code>mcp-ui</code> bridge to inject resources and call its own mcp tools.
						</p>
						<p>
							Each <code>application</code> is tagged in resource annotations so the host can detect them.
						</p>
					</div>
					<div class="ui-gallery">
						<figure class="ui-shot">
							<button
								type="button"
								class="ui-shot-button"
								data-lightbox-src="assets/images/mcp-application.png"
								data-lightbox-alt="MCP application view."
								data-lightbox-caption="MCP application view.">
								<img
									src="assets/images/mcp-application.png"
									alt="MCP application view."/>
							</button>
							<figcaption>MCP application view.</figcaption>
						</figure>
						<figure class="ui-shot">
							<button
								type="button"
								class="ui-shot-button"
								data-lightbox-src="assets/images/mcp-application-annotation.png"
								data-lightbox-alt="MCP application with annotations."
								data-lightbox-caption="Annotated MCP application view.">
								<img
									src="assets/images/mcp-application-annotation.png"
									alt="MCP application with annotations."/>
							</button>
							<figcaption>Annotated MCP application view.</figcaption>
						</figure>
					</div>
					<div class="longform-block">
						<h3>UI layer details</h3>
						<p>
							The file browser itself is a Vue 3 app. The standard build is
							about 75kb raw javascript, and an initial Vue Vapor build drops it to 57kb
              				with more room left to reduce. The goal is to ship lightweight
							applications.
						</p>
						<p>
							The host application that embeds the bridge must register a
							resolver for resources and tool calls to make the flow work.
						</p>
					</div>
					<div
						class="lightbox"
						id="lightbox"
						aria-hidden="true">
						<button
							type="button"
							class="lightbox-backdrop"
							data-lightbox-close
							aria-label="Close preview"></button>
						<div class="lightbox-content">
							<button
								type="button"
								class="lightbox-close"
								data-lightbox-close
								aria-label="Close">Close</button>
							<img class="lightbox-image" alt=""/>
							<p class="lightbox-caption"></p>
						</div>
					</div>
					<h3>Projects</h3>
					<div class="project-cards">
						<article class="project-card">
							<p class="project-label">mcp-fs</p>
							<h3>A file server that demonstrates the model</h3>
							<p>
								I implemented a rust-based file MCP server that showcases the UI extensions
                end-to-end. It includes diff views for every file edit and a broader file browser application.
							</p>
						</article>
						<article class="project-card">
							<p class="project-label">mcp-ui</p>
							<h3>MCP Bridge</h3>
							<p>
								A MCP-Apps inspired native web component to securely render the HTML artifacts
 				while allowing resolving of additional resources and tool calls.
 				It also has a starting point for standardizing css across tools.
							</p>
						</article>
						<article class="project-card">
							<p class="project-label">mcp-test</p>
							<h3>Testing it all</h3>
							<p>
								A tool to test MCP servers and specifically the UI extensions.
								It will dynamically detect the applications and content responses.
							</p>
						</article>
					</div>
				</div>
			</section>
			<section id="configuration" class="section reveal longform">
				<div class="section-title">
					<h2>Configuration and policies</h2>
					<p>Building on SEP-1596, I have introduced a way to dynamically send the actual configuration in the initialize exchange. After that, runtime policies can be used for each tool call to create restricted sandboxes on the fly.</p>
				</div>
				<div class="longform-content">
					<div class="longform-block">
						<h3>Schema-first configuration</h3>
						<p>
							Servers can publish their requirements during the <code>initialize</code> phase (SEP-1596) via <code>capabilities.configSchema</code>.
							This allows middleware to dynamically generate configuration UIs for the user. 
							In the provided <code>mcp-fs</code> server, you can also retrieve this schema directly via the <code>--print-config-schema</code> CLI flag.
						</p>
						<p>
							I've added an extension where the middleware can then take that user-provided configuration and send it in the initialize phase via <code>capabilities.experimental.configuration</code>.
							While the included <code>mcp-fs</code> server supports traditional environment variables and CLI flags, these initialization-time configurations take precedence, allowing for more flexible, stateful management..
						</p>
					</div>
					<div class="ui-gallery">
						<figure class="ui-shot">
							<button
								type="button"
								class="ui-shot-button"
								data-lightbox-src="assets/images/mcp-server-configuration.png"
								data-lightbox-alt="Server configuration overview in mcp-test."
								data-lightbox-caption="Server configuration overview.">
								<img
									src="assets/images/mcp-server-configuration.png"
									alt="Server configuration overview in mcp-test."/>
							</button>
							<figcaption>Server configuration overview.</figcaption>
						</figure>
						<figure class="ui-shot">
							<button
								type="button"
								class="ui-shot-button"
								data-lightbox-src="assets/images/mcp-server-schema.png"
								data-lightbox-alt="Configuration schema view for an MCP server."
								data-lightbox-caption="Configuration schema view.">
								<img
									src="assets/images/mcp-server-schema.png"
									alt="Configuration schema view for an MCP server."/>
							</button>
							<figcaption>Configuration schema view.</figcaption>
						</figure>
						<figure class="ui-shot">
							<button
								type="button"
								class="ui-shot-button"
								data-lightbox-src="assets/images/mcp-server-json-configuration.png"
								data-lightbox-alt="JSON configuration input in mcp-test."
								data-lightbox-caption="JSON configuration input.">
								<img
									src="assets/images/mcp-server-json-configuration.png"
									alt="JSON configuration input in mcp-test."/>
							</button>
							<figcaption>JSON configuration input.</figcaption>
						</figure>
					</div>
					<div class="longform-block">
						<h3>Runtime policies</h3>
						<p>
							Once a server is active, <b>Runtime Policies</b> allow for granular, per-call restrictions.
							This is vital when scoping an MCP server to a narrow domain for a specific task, or when an LLM needs to delegate a sub-task to a worker with limited exposure.
							The <code>mcp-fs</code> tool implements this by accepting a <code>_meta.policy</code> fragment in the call. These fragments act as a restrictive overlay on the primary configuration.
						</p>
						<p>
							<b>Crucial Security Rule:</b> A policy can only <b>restrict</b> configuration, never expand it. 
							For example, a policy can narrow a file root to a specific subfolder or add stricter "deny" globs, but it cannot grant access to a new root. Any attempt to expand permissions results in a JSON-RPC error.
						</p>
						<p>
							To manage this, I've introduced two attributes for configuration fields:
							<ul>
								<li><b>scope</b>: this is <code>configuration</code>, <code>policy</code> or <code>any</code> (default). Defines if a setting is set at startup, at runtime, or both.</li>
								<li><b>audience</b>: this is <code>human</code>, <code>llm</code> or <code>any</code> (default). Determines if a policy change can be requested by the LLM itself or must be configured by a human.</li>
							</ul>
						</p>
						<p>
							The included <code>mcp-fs</code> and <code>mcp-test</code> tools provide full reference implementations of these concepts.
						</p>
					</div>
					<div class="ui-gallery">
						<figure class="ui-shot">
							<button
								type="button"
								class="ui-shot-button"
								data-lightbox-src="assets/images/mcp-no-policy.png"
								data-lightbox-alt="Tool invocation without a policy."
								data-lightbox-caption="Tool invocation without a policy.">
								<img
									src="assets/images/mcp-no-policy.png"
									alt="Tool invocation without a policy."/>
							</button>
							<figcaption>Tool invocation without a policy.</figcaption>
						</figure>
						<figure class="ui-shot">
							<button
								type="button"
								class="ui-shot-button"
								data-lightbox-src="assets/images/mcp-with-policy.png"
								data-lightbox-alt="Tool invocation with a policy applied."
								data-lightbox-caption="Tool invocation with a policy applied.">
								<img
									src="assets/images/mcp-with-policy.png"
									alt="Tool invocation with a policy applied."/>
							</button>
							<figcaption>Tool invocation with a policy applied.</figcaption>
						</figure>
						<figure class="ui-shot">
							<button
								type="button"
								class="ui-shot-button"
								data-lightbox-src="assets/images/mcp-with-invalid-policy.png"
								data-lightbox-alt="Policy validation error shown to the agent."
								data-lightbox-caption="Policy validation error.">
								<img
									src="assets/images/mcp-with-invalid-policy.png"
									alt="Policy validation error shown to the agent."/>
							</button>
							<figcaption>Policy validation error.</figcaption>
						</figure>
						<figure class="ui-shot">
							<button
								type="button"
								class="ui-shot-button"
								data-lightbox-src="assets/images/mcp-immutable.png"
								data-lightbox-alt="Policy enforcing immutability for write operations."
								data-lightbox-caption="Policy enforcing immutability.">
								<img
									src="assets/images/mcp-immutable.png"
									alt="Policy enforcing immutability for write operations."/>
							</button>
							<figcaption>Policy enforcing immutability.</figcaption>
						</figure>
					</div>
				</div>
			</section>
			<section id="permissions" class="section reveal longform">
				<div class="section-title">
					<h2>Permissions</h2>
					<p>I wanted to use a set of permissions that is easy for the user to manage at a high level while 
						also allowing the user to dig deeper and configure it in detail when needed.
					</p>
				</div>
				<div class="longform-content">
					<div class="longform-block">
						<h3>Scopes that scale across tools</h3>
						<p>
							The goal is to let users tune permissions per session or per agent
              without drowning them in hundreds of tool-specific toggles. A flat
              permission list does not scale when you have dozens of MCP tools.
						</p>
						<p>
							A hierarchical scope layout solves this. Across all tools, the
              root capabilities should collapse into a small, clear set like
							<code>read</code>, <code>write</code> and <code>execute</code>.
              That lets users quickly tune an agent at a broad level before
              deciding whether they need finer control.
			</p>
			<p>
			  For example you might easily set up an agent that has <code>read:*</code> but disallowed <code>write:*</code> for a high level distinction.
						</p>
					</div>
					<div class="longform-block">
						<h3>Granularity when you actually need it</h3>
						<p>
							Scopes can carry detail, e.g.
							<code>write:file:/path/to</code>. This
              keeps the base policy simple while still allowing fine-grained
              control when a specific tool needs it. It also lets you express
              cases like
							<code>write:file</code>
							allowed but
							<code>write:database</code>
							denied, or vice-versa.
						</p>
					</div>
					<div class="longform-block">
						<h3>Dynamic permission requests</h3>
						<p>
							Example: a file server starts with configured roots. If the LLM
              tries to write outside those roots, the server returns an error by
              default, but also includes
							<code>requested_scopes</code>
							in
							<code>_meta</code>
							such as
							<code>write:file:/new/path</code>
							.
						</p>
						<p>
							The agent UI can ask the user to allow or deny the request. If the
              user approves, the call is replayed with
							<code>granted_scopes</code>
							.
              The grant can be stored for the session or only for that request.
						</p>
					</div>
					<div class="longform-block">
						<h3>Permission flow lives in the agent layer</h3>
						<p>
							Permission checks and prompts are not handled by the MCP server and
              do not pass through the LLM. The agent framework mediates approval
              and decides when to persist grants per session or per agent, based
              on what the workflow needs.
						</p>
					</div>
				</div>
			</section>
		</main>
		<footer class="site-footer">
			<div>mcp4h</div>
			<div>MCP Proposals</div>
		</footer>
		<script>
			(function () {
				var lightbox = document.getElementById("lightbox");
				if (!lightbox) {
					return;
				}
				var image = lightbox.querySelector(".lightbox-image");
				var caption = lightbox.querySelector(".lightbox-caption");
				var lastFocus = null;
				function openLightbox(trigger) {
					var src = trigger.getAttribute("data-lightbox-src");
					if (!src) {
						return;
					}
					image.src = src;
					image.alt = trigger.getAttribute("data-lightbox-alt") || "";
					caption.textContent = trigger.getAttribute("data-lightbox-caption") || "";
					lightbox.classList.add("is-open");
					lightbox.setAttribute("aria-hidden", "false");
					lastFocus = trigger;
				}
				function closeLightbox() {
					if (!lightbox.classList.contains("is-open")) {
						return;
					}
					lightbox.classList.remove("is-open");
					lightbox.setAttribute("aria-hidden", "true");
					image.src = "";
					image.alt = "";
					caption.textContent = "";
					if (lastFocus && typeof lastFocus.focus === "function") {
						lastFocus.focus();
					}
				}
				document.addEventListener(
					"click",
					function (event) {
						var trigger = event.target.closest("[data-lightbox-src]");
						if (trigger) {
							event.preventDefault();
							openLightbox(trigger);
							return;
						}
						var closeTarget = event.target.closest("[data-lightbox-close]");
						if (closeTarget) {
							event.preventDefault();
							closeLightbox();
						}
					}
				);
				window.addEventListener(
					"keydown",
					function (event) {
						if (event.key === "Escape") {
							closeLightbox();
						}
					}
				);
			})();
		</script>
	</body>
</html>
