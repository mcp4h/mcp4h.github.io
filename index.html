<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		<title>MCP For Humans</title>
		<link rel="preconnect" href="https://fonts.googleapis.com"/>
		<link
			rel="preconnect"
			href="https://fonts.gstatic.com"
			crossorigin/>
		<link
			href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600&family=Newsreader:opsz,wght@6..72,400;6..72,600&display=swap"
			rel="stylesheet"/>
		<link rel="stylesheet" href="styles.css"/>
	</head>
	<body>
		<header class="site-header">
			<div class="brand">
				<div class="brand-mark">mcp4h</div>
				<div class="brand-sub">MCP For Humans</div>
			</div>
			<nav class="site-nav">
				<a href="#ui">UI mediation</a>
				<a href="#permissions">Permissions</a>
				<a href="https://github.com/mcp4h">Github</a>
			</nav>
		</header>
		<main class="content">
			<section class="hero">
				<div class="hero-copy">
					<p class="eyebrow">MCP For Humans.</p>
					<h1>Informing the user</h1>
					<p class="lede">
						MCP servers can encapsulate data that the user might not have easy access to.
						This means informing the user of what will be done, what has been done and the overall state of the data
						can be a challenge.
					</p>
					<p class="lede">
						So I've suggested a few extensions which are inspired by MCP Apps, stay MCP-compatible, opt-in, and do not change normal
            operations or inflate LLM token use.
					</p>
					<div class="hero-actions">
						<a class="btn" href="#ui">Start with UI</a>
						<a class="btn ghost" href="https://github.com/mcp4h">Check out the code</a>
					</div>
				</div>
				<div class="hero-card">
					<div class="card-title">At a glance</div>
					<ul class="card-list">
						<li>Enrichment of tool calls</li>
						<li>Access to encapsulated data</li>
						<li>Standardized dry-run</li>
					</ul>
				</div>
			</section>
			<section id="ui" class="section reveal longform">
				<div class="section-title">
					<h2>UI Proposal</h2>
					<p>There are two challenges: informing a user what a tool call did or will do. And informing the user of the overall state of the system.</p>
					<p>It's important to note that the user typically needs <b>different information</b> for this than the LLM.</p>
				</div>
				<div class="longform-content">
					<div class="longform-block">
						<h2>P(review)</h2>
						<p>
							The first challenge in MCP is informing the user of the impact a particular tool action has.
							If the user just looks at tool input or output, it might not tell the whole story.
						</p>
						<p>
							The LLM has a context built up over the conversation which may consist of different tool calls and interactions.
							Based on that context the LLM decides to perform a tool call to "replace this line with this other line". 
							For the user however, looking just at the input might not be enough. He may want to see the broader context of that line to understands what the replacement means.
						</p>
						<p>
							In the file server I added to this project (the <code>mcp-fs</code> project), the <code>edit_file</code> tool call
							will always generate a visual diff (both unified and side-by-side) for human consumption and a structured diff for automated processing.
							If the tool call is simply allowed to pass, it can be stored for later viewing, however the server also supports a <code>_meta.preview</code> boolean toggle.
							This makes use of the MCP v2 addition of _meta keys to standardize a "dry run".
				 	 		The tool will generate the exact same output but not actually apply the change.
			  				The artifacts it generates can then be used to inform the user of what
							<i>would</i> happen were he to allow it. 
							Once allowed, the tool call can be rerun without the preview parameter.
						</p>
						<p>
							The screenshots are taken in the <code>mcp-test</code> tool which is also available and makes it easy to test the proposed extensions.
						</p>
					</div>
					<div class="ui-gallery">
						<figure class="ui-shot">
							<button
								type="button"
								class="ui-shot-button"
								data-lightbox-src="assets/images/mcp-invoke-preview.png"
								data-lightbox-alt="Preview of an MCP invoke with a dry-run summary."
								data-lightbox-caption="MCP invoke preview mode.">
								<img
									src="assets/images/mcp-invoke-preview.png"
									alt="Preview of an MCP invoke with a dry-run summary."/>
							</button>
							<figcaption>MCP invoke preview mode.</figcaption>
						</figure>
						<figure class="ui-shot">
							<button
								type="button"
								class="ui-shot-button"
								data-lightbox-src="assets/images/mcp-invoke-preview-ui1.png"
								data-lightbox-alt="Unified diff preview of an MCP invoke."
								data-lightbox-caption="Unified diff.">
								<img
									src="assets/images/mcp-invoke-preview-ui1.png"
									alt="Unified diff preview of an MCP invoke."/>
							</button>
							<figcaption>Unified diff.</figcaption>
						</figure>
						<figure class="ui-shot">
							<button
								type="button"
								class="ui-shot-button"
								data-lightbox-src="assets/images/mcp-invoke-preview-ui2.png"
								data-lightbox-alt="Full screen unified diff."
								data-lightbox-caption="Fullscreen unified diff.">
								<img
									src="assets/images/mcp-invoke-preview-ui2.png"
									alt="Full screen unified diff."/>
							</button>
							<figcaption>Fullscreen unified diff.</figcaption>
						</figure>
						<figure class="ui-shot">
							<button
								type="button"
								class="ui-shot-button"
								data-lightbox-src="assets/images/mcp-invoke-preview-ui3.png"
								data-lightbox-alt="Side by side diff view of the change."
								data-lightbox-caption="Side-by-side diff.">
								<img
									src="assets/images/mcp-invoke-preview-ui3.png"
									alt="Side by side diff view of the change."/>
							</button>
							<figcaption>Side-by-side diff.</figcaption>
						</figure>
						<figure class="ui-shot">
							<button
								type="button"
								class="ui-shot-button"
								data-lightbox-src="assets/images/mcp-invoke-preview-ui4.png"
								data-lightbox-alt="Dedicated diff output"
								data-lightbox-caption="Dedicated diff output">
								<img
									src="assets/images/mcp-invoke-preview-ui4.png"
									alt="Dedicated diff output"/>
							</button>
							<figcaption>Dedicated diff output</figcaption>
						</figure>
						<figure class="ui-shot">
							<button
								type="button"
								class="ui-shot-button"
								data-lightbox-src="assets/images/mcp-resources.png"
								data-lightbox-alt="Combination of static and dynamic resources."
								data-lightbox-caption="Combination of static and dynamic resources.">
								<img
									src="assets/images/mcp-resources.png"
									alt="Combination of static and dynamic resources."/>
							</button>
							<figcaption>Combination of static and dynamic resources.</figcaption>
						</figure>
					</div>
					<div class="longform-block">
						<h3>How the UI layer is delivered</h3>
						<p>
							Inspired by MCP apps, there is an MCP bridge (available in <code>mcp-ui</code>): a native web
              				component that renders HTML inside a sandboxed iframe. It exposes
              				a standard set of CSS variables that can be configured on the
							<code>mcp-view</code>, allowing the MCP UI to blend into the host
							application.
						</p>
						<p>
							For the file server, each <code>edit-file</code>
							tool call generates a temporary dynamic resource. 
							If you <i>can</i> inform the user based solely on input/output, static resources are also possible.
							The link is currently added to the <code>content</code> array.
						</p>
					</div>
					<div class="longform-block">
						<h2>Context beyond a single tool call</h2>
						<p>
							MCP servers are frequently black boxes. They manage datasets the
							user might not be able to easily access, such as a remote or containerized instance. 
						</p>
						<p>
						  Sometimes the user needs more information regarding the state of the data.
						  This can help him decide which path to take or understand a larger set of changes.
						</p>
						<p>
							In the example file server I added this takes the form of a "file browser".
							It uses the same <code>mcp-ui</code> bridge to inject resources and call its own mcp tools.
						</p>
						<p>
							Each <code>application</code> is tagged in resource annotations so the host can detect them.
						</p>
					</div>
					<div class="ui-gallery">
						<figure class="ui-shot">
							<button
								type="button"
								class="ui-shot-button"
								data-lightbox-src="assets/images/mcp-application.png"
								data-lightbox-alt="MCP application view."
								data-lightbox-caption="MCP application view.">
								<img
									src="assets/images/mcp-application.png"
									alt="MCP application view."/>
							</button>
							<figcaption>MCP application view.</figcaption>
						</figure>
						<figure class="ui-shot">
							<button
								type="button"
								class="ui-shot-button"
								data-lightbox-src="assets/images/mcp-application-annotation.png"
								data-lightbox-alt="MCP application with annotations."
								data-lightbox-caption="Annotated MCP application view.">
								<img
									src="assets/images/mcp-application-annotation.png"
									alt="MCP application with annotations."/>
							</button>
							<figcaption>Annotated MCP application view.</figcaption>
						</figure>
					</div>
					<div class="longform-block">
						<h3>UI layer details</h3>
						<p>
							The file browser itself is a Vue 3 app. The standard build is
							about 75kb raw javascript, and an initial Vue Vapor build drops it to 57kb
              				with more room left to reduce. The goal is to ship lightweight
							applications.
						</p>
						<p>
							The host application that embeds the bridge must register a
							resolver for resources and tool calls to make the flow work.
						</p>
					</div>
					<div
						class="lightbox"
						id="lightbox"
						aria-hidden="true">
						<button
							type="button"
							class="lightbox-backdrop"
							data-lightbox-close
							aria-label="Close preview"></button>
						<div class="lightbox-content">
							<button
								type="button"
								class="lightbox-close"
								data-lightbox-close
								aria-label="Close">Close</button>
							<img class="lightbox-image" alt=""/>
							<p class="lightbox-caption"></p>
						</div>
					</div>
					<h3>Projects</h3>
					<div class="project-cards">
						<article class="project-card">
							<p class="project-label">mcp-fs</p>
							<h3>A file server that demonstrates the model</h3>
							<p>
								I implemented a rust-based file MCP server that showcases the UI extensions
                end-to-end. It includes diff views for every file edit and a broader file browser application.
							</p>
						</article>
						<article class="project-card">
							<p class="project-label">mcp-ui</p>
							<h3>MCP Bridge</h3>
							<p>
								A MCP-Apps inspired native web component to securely render the HTML artifacts
 				while allowing resolving of additional resources and tool calls.
 				It also has a starting point for standardizing css across tools.
							</p>
						</article>
						<article class="project-card">
							<p class="project-label">mcp-test</p>
							<h3>Testing it all</h3>
							<p>
								A tool to test MCP servers and specifically the UI extensions.
								It will dynamically detect the applications and content responses.
							</p>
						</article>
					</div>
				</div>
			</section>
			<section id="permissions" class="section reveal longform" style="display:none">
				<div class="section-title">
					<h2>Permissions</h2>
					<p>Designing scopes that scale across tools, sessions, and UI flows.</p>
				</div>
				<div class="longform-content">
					<div class="longform-block">
						<h3>Scopes that scale across tools</h3>
						<p>
							The goal is to let users tune permissions per session or per agent
              without drowning them in hundreds of tool-specific toggles. A flat
              permission list does not scale when you have dozens of MCP tools.
						</p>
						<p>
							A hierarchical scope layout solves this. Across all tools, the
              root capabilities should collapse into a small, clear set like
							<code>read</code>
							,
							<code>write</code>
							, and
							<code>execute</code>
							.
              That lets users quickly tune an agent at a broad level before
              deciding whether they need finer control.
						</p>
					</div>
					<div class="longform-block">
						<h3>Granularity when you actually need it</h3>
						<p>
							Scopes can carry detail, e.g.
							<code>write:file:/path/to</code>
							. This
              keeps the base policy simple while still allowing fine-grained
              control when a specific tool needs it. It also lets you express
              cases like
							<code>write:file</code>
							allowed but
							<code>write:database</code>
							denied, or vice-versa.
						</p>
					</div>
					<div class="longform-block">
						<h3>Dynamic permission requests</h3>
						<p>
							Example: a file server starts with configured roots. If the LLM
              tries to write outside those roots, the server returns an error by
              default, but also includes
							<code>requested_scopes</code>
							in
							<code>_meta</code>
							such as
							<code>write:file:/new/path</code>
							.
						</p>
						<p>
							The agent UI can ask the user to allow or deny the request. If the
              user approves, the call is replayed with
							<code>granted_scopes</code>
							.
              The grant can be stored for the session or only for that request.
						</p>
					</div>
					<div class="longform-block">
						<h3>Permission flow lives in the agent layer</h3>
						<p>
							Permission checks and prompts are not handled by the MCP server and
              do not pass through the LLM. The agent framework mediates approval
              and decides when to persist grants per session or per agent, based
              on what the workflow needs.
						</p>
					</div>
				</div>
			</section>
		</main>
		<footer class="site-footer">
			<div>mcp4h</div>
			<div>MCP For Humans</div>
		</footer>
		<script>
			(function () {
				var lightbox = document.getElementById("lightbox");
				if (!lightbox) {
					return;
				}
				var image = lightbox.querySelector(".lightbox-image");
				var caption = lightbox.querySelector(".lightbox-caption");
				var lastFocus = null;
				function openLightbox(trigger) {
					var src = trigger.getAttribute("data-lightbox-src");
					if (!src) {
						return;
					}
					image.src = src;
					image.alt = trigger.getAttribute("data-lightbox-alt") || "";
					caption.textContent = trigger.getAttribute("data-lightbox-caption") || "";
					lightbox.classList.add("is-open");
					lightbox.setAttribute("aria-hidden", "false");
					lastFocus = trigger;
				}
				function closeLightbox() {
					if (!lightbox.classList.contains("is-open")) {
						return;
					}
					lightbox.classList.remove("is-open");
					lightbox.setAttribute("aria-hidden", "true");
					image.src = "";
					image.alt = "";
					caption.textContent = "";
					if (lastFocus && typeof lastFocus.focus === "function") {
						lastFocus.focus();
					}
				}
				document.addEventListener(
					"click",
					function (event) {
						var trigger = event.target.closest("[data-lightbox-src]");
						if (trigger) {
							event.preventDefault();
							openLightbox(trigger);
							return;
						}
						var closeTarget = event.target.closest("[data-lightbox-close]");
						if (closeTarget) {
							event.preventDefault();
							closeLightbox();
						}
					}
				);
				window.addEventListener(
					"keydown",
					function (event) {
						if (event.key === "Escape") {
							closeLightbox();
						}
					}
				);
			})();
		</script>
	</body>
</html>
